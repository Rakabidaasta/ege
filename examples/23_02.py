# Тип №23. Количество программ с обязательным этапом 
# Задание №11358
# Задания для самопроверки: №13498, №13525

# Исполнитель А16 преобразует число, записанное на экране.
# У исполнителя есть три команды, которым присвоены номера:
def f(start, end):
    if start == end:
        return 1
    if start > end:
        return 0

    # 1.  Прибавить 1
    # 2.  Прибавить 2
    # 3.  Умножить на 2
    return f(start + 1, end) + f(start + 2, end) + f(start * 2, end)

# Сколько существует таких программ, которые исходное число 3 преобразуют в число 12 и при этом траектория вычислений программы содержит число 10?
print(f(3, 10) * f(10, 12))

'''
В этой задаче я поставила знак умножения между f(3, 10) и f(10, 12), потому что так надо :)
Разберём пример:
У нас есть три города - Петрозаводск, Санк-Петербург, Москва

Из ПТЗ в СПб можно добраться 2 способами. Из СПб в МСК 3 способами.
Мы можем из ПТЗ в СПб через первый, из СПб в МСК через первый
         из ПТЗ в СПб через первый, из СПб в МСК через второй
         из ПТЗ в СПб через первый, из СПб в МСК через третий
         из ПТЗ в СПб через второй, из СПб в МСК через первый
         из ПТЗ в СПб через второй, из СПб в МСК через второй
         из ПТЗ в СПб через второй, из СПб в МСК через третий

Итого 6 вариантов: 2 из ПТЗ в СПб * 3 из СПб в МСК
'''

# Тип №23. Количество программ с обязательным этапом 
# Задание №58214
# Задания для самопроверки: №58216

# Исполнитель Увеличитель преобразует число на экране.
# У исполнителя есть две команды, которым присвоены номера:
def f(start, end):
    if start == end:
        return 1
    if start < end:
        return 0

    # 1.  Вычти 1;
    # 2.  Найди целую часть от деления на 3.
    return f(start - 1, end) + f(start // 3, end)

# Сколько существует программ, для которых при исходном числе 67 результатом является число 5, и при этом траектория вычислений содержит число 33?
print(f(67, 33) * f(33, 5))

'''
Вопрос: почему я до этого писала 
if start > end:
    return 0
А тут резко 
if start < end:
    return 0

Ответ: знак зависит от операций, которые совершаются над числом
- Если мы добавляем и умножаем, значит мы не должны перескочить число в большую сторону.
  Потому что мы никак не сможем вернуться назад. И соответственно если start > end, 
  то нас такой исход не устраивает return 0

- Если мы вычитаем и делим, значит мы не должны перескочить число в меньшую сторону.
  Потому что мы никак не сможем вернуться вперёд. И соответственно если start < end, 
  то нас такой исход не устраивает return 0
'''
